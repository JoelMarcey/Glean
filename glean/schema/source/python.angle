schema python.1 {
import builtin.1
import src.1

predicate Name: string
predicate Type: string

# Records that a class exists with the given fully qualified name.
predicate ClassDeclaration:
  {
    name: Name,
    bases: maybe [Name],  # unused, see ClassDefinition below
  }
# Records that a function exists with the given fully qualified name.
# The function can be a global, local, or a class method.
predicate FunctionDeclaration: { name: Name }
# Records that a variable exists with the given fully qualified name.
# This variable can be global, or scoped to a class.
predicate VariableDeclaration: { name: Name }
# Records that a Python module exists with a given fully qualified name.
predicate Module: { name: Name }

# DEPRECATED in favor of schema version 2
predicate ImportStatement:
  {
    name: Name, # QName of symbol being imported
    as_name: maybe Name,
    span: src.ByteSpan,
  }

# DEPRECATED in favor of schema version 2
type Declaration =
  {
    cls: ClassDeclaration |
    func: FunctionDeclaration |
    variable: VariableDeclaration |
  }

# DEPRECATED in favor of schema version 2
predicate DeclarationLocation:
  {
    declaration: Declaration,
    file: src.File,
    span: src.ByteSpan,
  }

# DEPRECATED in favor of schema version 2
predicate FileXRefs:
  {
    file: src.File,
    xrefs: [XRef],
  }

# DEPRECATED in favor of schema version 2
type XRef =
  {
    target: XRefTarget,
    source: src.ByteSpan,
  }

# DEPRECATED in favor of schema version 2
type XRefTarget =
  {
    declaration: Declaration |
    module: Module |
    indirect: XRefIndirectTarget |
    unknown: builtin.Unit |
  }

# DEPRECATED in favor of schema version 2
predicate XRefIndirectTarget:
  {
    import_statement: ImportStatement,
    target: XRefTarget,
  }

# DEPRECATED in favor of schema version 2
predicate TargetUses:
  {
    target: XRefTarget,
    file: src.File,
    uses: src.ByteSpans,
  }

} # python.1

schema python.2 : python.1 {

import builtin.1
import src.1

# A structured name.
predicate SName:
  {
    local_name: Name,
    parent: maybe SName,
  }

predicate NameToSName: Name -> SName
predicate SNameToName: SName -> Name
  stored SN -> N where NameToSName N -> SN

# Allows efficient queries for modules by structured name.
predicate ModuleBySName: SName -> Module
  stored SN -> M where SNameToName SN -> N; Module {name = N} = M

predicate ModuleDefinition:
  {
    module: Module,
    docstring: maybe Docstring,
  }

# Allows efficient queries for classes by structured name
predicate ClassBySName: SName -> ClassDeclaration
  stored SN -> C where SNameToName SN -> N; ClassDeclaration {name = N} = C

# Represents details about a class with a particular name.
predicate ClassDefinition:
  {
    declaration: ClassDeclaration,
    # nothing means the indexer doesn't support detecting these features
    bases: maybe [ClassDeclaration],
    keywords: maybe [Parameter],  # metaclass parameters
    decorators: maybe [Decorator],
    docstring: maybe Docstring,
  }

# Allows efficient queries for functions by structured name.
predicate FunctionBySName: SName -> FunctionDeclaration
  stored SN -> F where SNameToName SN -> N; FunctionDeclaration {name = N} = F

# Represents details about a function with a particular name.
predicate FunctionDefinition:
  {
    declaration: FunctionDeclaration,
    is_async: bool,
    returns: maybe Type,
    params: [Parameter],  # "regular" parameters (can be pos or kwarg)
    # nothing means the indexer doesn't support detecting these features
    posonly_params: maybe [Parameter],
    kwonly_params: maybe [Parameter],
    star_arg: maybe Parameter,  # *args
    star_kwarg: maybe Parameter,  # **kwargs
    decorators: maybe [Decorator],
    docstring: maybe Docstring,
  }

# Allows efficient queries for variables by structured name.
predicate VariableBySName: SName -> VariableDeclaration
  stored SN -> V where SNameToName SN -> N; VariableDeclaration {name = N} = V

# Represents details about a variable.
predicate VariableDefinition:
  {
    declaration: VariableDeclaration,
    type: maybe Type,
  }

type Parameter =
  {
    name: Name,
    type: maybe Type,
    # value is only filled out for metaclass parameters
    # (see the `keywords` field in `ClassDefinition`)
    value: maybe string,
  }

# Decorators can be arbitrary expressions, this just records their string
# representation.
type Decorator = string
predicate DocstringContent: string
type Docstring =
  {
    location: src.ByteSpan,
  }

# A concrete symbol being imported.
# A single import statement that pulls in multiple names generates multiple
# facts of this predicate. Star imports are not represented.
predicate ImportStatement:
  {
    # fully qualified name of the imported symbol
    from_name: Name,
    # fully qualified name that is the effect of the import statement
    as_name: Name,
  }

type Declaration =
  {
    cls: ClassDeclaration |
    func: FunctionDeclaration |
    variable: VariableDeclaration |
    imp: ImportStatement |
    module: Module |
  }

# The location of a Declaration relative to the repo root.
predicate DeclarationLocation:
  {
    declaration: Declaration,
    file: src.File,
    span: src.ByteSpan,
  }

# A cross reference, or access to a symbol.
# This type captures a variable access with the LOAD expression
# context in the Python AST. This type is only valid in the context
# of a FileXRefs predicate. `target` is a fully qualified name.
type XRefViaName =
    {
        target: Name,
        source: src.ByteSpan,
    }

# Collects all reference to names in a single file.
# There is only one fact of this predicate per source file in the repo.
predicate XRefsViaNameByFile:
    {
        file: src.File,
        xrefs: [XRefViaName],
    }

# All uses of a declaration in a particular file.
# This predicate does not follow references, so if a symbol is used through
# a chain of imports, only the first hop will be present as a fact.
# Querying this predicate by declaration is an efficient way to find immediate
# references to
predicate DeclarationUses:
  {
    declaration: Declaration,
    file: src.File,
    span: src.ByteSpan,
  }
  stored {Decl, File, Span} where
  XRefsViaNameByFile { File, XRefs };
  { target = Name, source = Span } = XRefs[..];
  DeclarationByName Name -> Decl;

# This is a variant of TargetUses, but it allows efficient queries per file.
# It's useful for finding all outgoing references from a file
# (e.g. for click-to-definition).
predicate FileDirectXRefs:
  {
    file: src.File,
    xrefs: [DirectXRef],
  }

predicate DirectXRefsByFile:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, XRef} where
  XRefsViaNameByFile { File, XRefsViaName };
  { target = Name, source = Source } = XRefsViaName[..];
  DeclarationByName Name -> Decl;
  XRef = DirectXRef {target = Decl, source = Source};

type DirectXRef =
  {
    target: Declaration,
    source: src.ByteSpan,
  }


predicate DeclarationToName: Declaration -> Name
  D -> N where
    ({cls = { name = N }} = D) |
    ({func = { name = N }} = D) |
    ({variable = { name = N }} = D) |
    ({imp = { as_name = N }} = D) |
    ({module = { name = N }} = D)

# Search for a declaration by (fully qualified) name.
predicate DeclarationByName: Name -> Declaration
  N -> D where
  D = (
    Declaration { cls = { name = N }}
  ) | (
    Declaration { func = { name = N }}
  ) | (
    Declaration { variable = { name = N }}
  ) | (
    ImportStatementByName { as_name = N, from_name = F };
    Declaration { imp = { from_name = F, as_name = N }}
  ) | (
    Declaration { module = { name = N }}
  )

# Search for a declaration by structured name
predicate DeclarationBySName: SName -> Declaration
  N -> D where
  D = (
    ClassBySName N -> C;
    Declaration { cls = C }
  ) | (
    FunctionBySName N -> F;
    Declaration { func = F }
  ) | (
    VariableBySName N -> V;
    Declaration { variable = V }
  ) | (
    ImportStatementByAsSName N -> I;
    Declaration { imp = I }
  ) | (
    ModuleBySName N -> M;
    Declaration { module = M }
  )

# This is a variant of DeclarationLocation. It allows for efficient queries
# by file.
predicate DeclarationsByFile:
  {
    file: src.File,
    span: src.ByteSpan,
    declaration: Declaration,
  }
  stored {File, Span, Declaration} where
  DeclarationLocation { Declaration, File, Span }


#### DEPRECATED SECTION

# DEPRECATED: use ImportStatementByAsName.3
predicate ImportStatementByAsName: Name -> ImportStatement
  stored Name -> I
  where ImportStatement { as_name = Name } = I

# DEPRECATED: use ImportStatementByAsSName.3
predicate ImportStatementByAsSName: SName -> ImportStatement
  AsSName -> I
  where SNameToName AsSName -> AsName; ImportStatementByAsName AsName -> I

# DEPRECATED: use ImportStatementByAsName.3
# This is the inverse of ImportStatement. It allows for efficient queries
# by alias.
predicate ImportStatementByName:
  {
    as_name: Name,
    from_name: Name,
  }
  stored {AsName, FromName} where ImportStatement {FromName, AsName}

# DEPRECATED: use DeclarationByName
# Search for a declaration by (fully qualified) name.
predicate DeclarationWithName:
  {
    name: Name,
    declaration: Declaration,
  }
  {N, D} where
  D = (
    Declaration { cls = { name = N }}
  ) | (
    Declaration { func = { name = N }}
  ) | (
    Declaration { variable = { name = N }}
  ) | (
    ImportStatementByName { as_name = N, from_name = F };
    Declaration { imp = { from_name = F, as_name = N }}
  ) | (
    Declaration { module = { name = N }}
  )

# DEPRECATED
type XRefTarget =
  {
    # Another symbol contained within the repo.
    declaration: Declaration |
    # DEPRECATED: another symbol, possibly outside of the repo.
    indirect: XRefIndirectTarget |
    # A symbol that's outside the indexed repo.
    unknown: builtin.Unit |
  }

# DEPRECATED: A reference to an import that might or might not point to
# a symbol within the repo.
# NOTE: this is a predicate to avoid cycles
predicate XRefIndirectTarget:
  {
    import_statement: ImportStatement,
    target: XRefTarget,
  }

# DEPRECATED: Use DeclarationUses
predicate TargetUses:
  {
    target: XRefTarget,
    file: src.File,
    uses: src.ByteSpans,
  }

# DEPRECATED: use XRefsViaNameByFile
predicate FileXRefs:
  {
    file: src.File,
    xrefs: [XRef],
  }

# DEPRECATED: use XRefViaName
type XRef =
  {
    # What symbol this access refers to.
    target: XRefTarget,
    # Where is the access in the context of the file in the containing
    # FileXRefs fact.
    source: src.ByteSpan,
  }

} # python.2

schema python.3 : python.2 {

# This is the inverse of ImportStatement. It allows for efficient queries
# by alias. Note that multiple ImportStatements might have the same
# alias, so this must be a record and not Name -> ImportStatement.
predicate ImportStatementByAsName: 
  { 
    name : Name, 
    import_ : ImportStatement 
  }
  stored 
  { Name, I } where ImportStatement { as_name = Name } = I

# Same as ImportStatementByAsName, but for structured names.
predicate ImportStatementByAsSName: 
  {
     sname : SName,
     import_ : ImportStatement
  }
  { AsSName, I }
  where 
    SNameToName AsSName -> AsName; 
    ImportStatementByAsName { AsName, I }

}
