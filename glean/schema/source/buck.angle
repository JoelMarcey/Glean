# Copyright (c) Facebook, Inc. and its affiliates.

schema buck.1 {
import sys.1
import src.1

# Targets in buck
predicate Target :
  {
    repo : sys.Blob,
    name : sys.Blob,
    platform : maybe sys.Blob,
  }

# A translation unit (source file and target)
predicate TranslationUnit :
  {
    file : src.File,
    target : Target,
  }

# A target locator (subdir//path:name), subdir can be empty
predicate Locator :
  {
    subdir : maybe string,
    path : string,
    name : string,
  }

# A source file reference (either from the repo or generated during build)
predicate File :
  {
    source : src.File |
    generated : Locator
  }

# Buck target type (cxx_libary, cxx_binary, ...)
predicate Type : string

# Buck platform (fbsource specific)
predicate Platform : string

# Buck label
predicate Label : string

# A set of Buck labels
predicate Labels : [Label]

# Buck dependency (buck.direct_deps)
type Dependency =
  {
    target : Locator,
    explicit_ : bool,  # is it in deps in fbsource?
    exported : bool,  # is it in exported_deps in fbsource?
  }

# Reverse locator dependencies derived from buck.TargetDependencies
predicate LocatorReverseDeps :
  {
    locator : Locator,  # unique key
    rdeps : [Locator],
  }

# From buck targets --show-target-hash
predicate TargetHash :
  {
    locator : Locator,  # unique key
    targetHash : string,
  }

# From buck targets --show-rulekey
predicate RuleKey :
  {
    locator : Locator,  # unique key
    ruleKey : string,
  }

}

schema buck.2 : buck.1 {
import src.1

# Buck target
predicate Target :
  {
    locator : Locator,
    type_ : Type,
    defaultPlatform : maybe Platform,
    labels : Labels,
  }

# Buck target dependencies
predicate TargetDependencies.1 :
  {
    target : Target,
    dependencies : [Dependency],
  }

# A translation unit (source file and target)
predicate TranslationUnit :
  {
    file : src.File,
    target : Locator,
    platform : maybe Platform,
  }

# Buck target link_whole flag
predicate TargetLinkWhole.1 : Target

# Buck target sources
predicate TargetSources.1 :
  {
    target : Target,
    headers : [File],
    exportedHeaders : [File],
    srcs : [File],
  }

# Buck target output, indexed by target
predicate TargetOut.1 :
  {
    target : Target,
    file : src.File,
  }

# Buck target output, indexed by file
predicate OutTarget.1 :
  {
    file : src.File,
    target : Target,
  }
  stored {F,T} where TargetOut {T,F}

# Which targets mention a file in headers, exportedHeaders, or srcs.
# Derived from buck.TargetSources
predicate Owner.1 :
  {
    source : src.File,  # unique key
    owner : TargetSources,
  }
  stored
  {Src,Owner} where
    Owner = TargetSources
    {
      headers = Headers,
      exportedHeaders = Exported,
      srcs = Srcs
    };
    Src =
    (S where F = Headers [..]; F = File { source = S }) |
    (S where F = Exported [..]; F = File { source = S }) |
    (S where F = Srcs [..]; F = File { source = S })

} # end schema buck.2

schema buck.3 : buck.2 {
import src.1

# Named output use OutputLabel as the key, the 'baz' in the form:
# //foo:bar[baz]
predicate OutputLabel : string

# The named output use locators that end with an extra optional key, e.g.
# 'baz' in //foo:bar[baz]
predicate LocatorWithLabel :
  {
    locator : Locator,
    label : OutputLabel
  }

# Buck target output, indexed by target. These are present if the named outputs
# (the "outs" in buck query) are present.
#
# The "default_outs" attribute is represented by Nothing as the outputLabel.
# If TargetOuts exists for a Target then there ought to be
# an outputLabel = nothing as well.
# The file with (outputLabel = nothing) may or may not
# be present with (outputLabel = just _), the default file can be distinct from
# the files of all labeled outputs.
#
# The target and outputLabel *should* uniquely determine the file,
# but that invariant isn't enforced by the Buck output which returns
# the file as a singleton list, so to be on the safe side this
# predicate allows for the possibility of multiple files per
# (target,outputLabel).

predicate TargetOuts :
  {
    target : Target,
    outputLabel : maybe OutputLabel,  # Nothing means the default_output
    file : src.File
  }

# derived predicate, reverse of TargetOuts. The same file may have duplicate
# OutsTarget facts. In particular the outputLabel of nothing
# ("default_outs" attribute) may overlap with a just value.
predicate OutsTarget :
  {
    file : src.File,
    target: Target,
    outputLabel : maybe OutputLabel
  }
  stored
  {SF, T, OL} where TargetOuts {T, OL, SF}

# A source file reference (either from the repo or generated during build)
predicate File :
  {
    source : src.File |
    generated : Locator |
    generatedLabel : LocatorWithLabel
  }

derive File default
  ({ source = X } where buck.File.1 {source = X}) ++
  ({ generated = X } where buck.File.1 {generated = X})

derive buck.File.1 default
  ({ source = X } where File {source = X}) ++
  ({ generated = X } where File {generated = X})

# Resolve source and generated files to the src.File itself.
predicate FileResolved :
  {
    buckFile : File,
    srcFile : src.File
  }
  {BF, SF} where
  SF =
    (SF1 where File { source = SF1 } = BF) ++
    (SF2 where
      File { generated = Loc } = BF;
      buck.TargetOuts{target = {locator = Loc},
        outputLabel = nothing, file = SF2}) ++
    (SF3 where
      File {generatedLabel = LocatorWithLabel{locator = Loc, label = Lab}} = BF;
      buck.TargetOuts{target = {locator = Loc},
        outputLabel = {just = Lab}, file = SF3});

# New versions of predicates that now depend on File

# Buck target sources
predicate TargetSources :
  {
    target : Target,
    headers : [File],
    exportedHeaders : [File],
    srcs : [File],
  }

# Which targets mention a file in headers, exportedHeaders, or srcs.
# (Making the TargetSources a direct owner of the file).
#
# For indirect mentions, via locators, see the Consumer predicate.
predicate Owner :
  {
    source : src.File,  # unique key
    owner : TargetSources,
  }
  stored
  {Src, Owner} where
    Owner = TargetSources
    {
      headers = Headers,
      exportedHeaders = Exported,
      srcs = Srcs
    };
    File { source = Src } = Headers[..] | Exported[..] | Srcs [..];

# New predicate that depends on File

# Which targets consume a (possibly named) output of another rule.
# (Making the TargetSources a consumer of the file).
predicate Consumer :
  {
    source : src.File,  # unique key
    consumer : TargetSources,
  }
  stored
  {Src, Consumer} where
    Consumer = TargetSources
    {
      headers = Headers,
      exportedHeaders = Exported,
      srcs = Srcs
    };
    BF = Headers[..] | Exported[..] | Srcs [..];
    FileResolved{buckFile = BF, srcFile= Src}

# Name for TargetIndexer, indicating which indexing pass created the target
predicate TargetIndexerName : string

# Associate a Target with a group, useful for identifying which indexing
# pass is planned
predicate TargetIndexer :
  {
    name : TargetIndexerName,
    target : Target
  }

} # end schema buck.3
