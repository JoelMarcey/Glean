schema flow.3 {
import src.1

predicate Module: {
  file: src.File |
  builtin |
  lib: string |
  noSource |
  string_: string |
}

predicate FileOfStringModule: {
  file: src.File,
  string_: string,
}

predicate StringToFileModule: {
  string_: string,
  file: src.File,
}
  stored { S, F } where FileOfStringModule { F, S }

predicate Range: {
  module : Module,
  span: src.ByteSpan,
}

predicate Name: string
predicate Type: string
predicate Documentation: Range

predicate Declaration: {
  name: Name,
  loc: Range,
}

predicate DeclarationInfo: {
  declaration: Declaration,
  type: Type,
  documentation: maybe Documentation,
}

# connects a variable to its declaration within the same file
predicate LocalDeclarationReference: {
  declaration: Declaration,
  loc: Range,
}

predicate MemberDeclaration: {
  name: Name,
  loc: Range,
}

predicate MemberDeclarationReference: {
  memberDeclaration: MemberDeclaration,
  loc: Range,
}

predicate MemberDeclarationInfo: {
  memberDeclaration: MemberDeclaration,
  type: Type,
  documentation: maybe Documentation,
}

predicate Export: {
  commonJS |              # module.exports
  commonJSMember: Name |  # module.exports.foo
  named: Name |           # export { foo }
  default_ |              # export default
  star: Module |          # export * from 'module'
}
predicate ModuleExport: {
  module: Module,
  export_: Export,
}

# indicates that a declaration is an import statement
predicate ImportDeclaration: {
  declaration: Declaration,
  import_: {
    moduleExport: ModuleExport |
    moduleNamespace: Module |
  }
}

# associates an exported symbol with where in the module the symbol was declared
predicate SourceOfExport: {
  moduleExport: ModuleExport,
  source: {
    declaration: Declaration |
    memberDeclaration: MemberDeclaration |
    moduleExport: ModuleExport |
    moduleNamespace: Module |
  },
}

predicate TypeDeclaration: {
  name: Name,
  loc: Range,
}

predicate TypeDeclarationReference: {
  typeDeclaration: TypeDeclaration,
  loc: Range,
}

predicate TypeDeclarationInfo: {
  typeDeclaration: TypeDeclaration,
  type: Type,
  documentation: maybe Documentation,
}

predicate TypeExport: {
  named: Name |   # export type
  star: Module |  # export
}
predicate ModuleTypeExport: {
  module: Module,
  typeExport: TypeExport,
}

predicate TypeImportDeclaration: {
  typeDeclaration: TypeDeclaration,
  import_: {
    type: ModuleTypeExport |
    typeof_: ModuleExport |
    moduleTypeof: Module |
  }
}

predicate SourceOfTypeExport: {
  moduleTypeExport: ModuleTypeExport,
  source: {
    typeDeclaration: TypeDeclaration |
    moduleTypeExport: ModuleTypeExport |
    moduleNamespace: Module |
  }
}

# Maps a src.File to the references within it. This is derived
# automatically from the other references, and is used to provide
# language-neutral reference info via the codemarkup schema.
predicate FileXRef : {
  file : src.File,
  ref : XRef
}
  stored
  ( { F, { localRef = L }} where
    L = LocalDeclarationReference { loc = Loc };
    { module = Mod } = Loc;
    { file = F } = Mod ) |
  ( { F, { memberRef = M }} where
    M = MemberDeclarationReference { loc = Loc } ;
    { module = Mod } = Loc;
    { file = F } = Mod ) |
  ( { F, { typeRef = T }} where
    T = TypeDeclarationReference { loc = Loc };
    { module = Mod } = Loc;
    { file = F } = Mod )

type XRef = {
  localRef : LocalDeclarationReference |
  memberRef : MemberDeclarationReference |
  typeRef : TypeDeclarationReference |
}

# Reverse XRefs: find-references for a declaration
predicate DeclarationUses :
  {
    target : flow.SomeDeclaration,
    file : src.File,
    use : src.ByteSpan
  }
  ( { target = { localDecl = D }, file = F, use = Span } where
    LocalDeclarationReference { declaration = D, loc = Range };
    { module = { file = F } , span = Span } = Range ) |
  ( { target = { memberDecl = D }, file = F, use = Span } where
    MemberDeclarationReference { memberDeclaration = D, loc = Range };
    { module = { file = F }, span = Span } = Range ) |
  ( { target = { typeDecl = D }, file = F, use = Span } where
    TypeDeclarationReference { typeDeclaration = D, loc = Range };
    { module = { file = F }, span = Span } = Range )

# Maps a src.File to the declarations it contains. This is derived
# automatically from the declarations, and is used to provide
# language-neutral declaration info via the codemarkup schema.
predicate FileDeclaration: {
  file : src.File,
  declaration : SomeDeclaration
}
  stored
  ( { F, { localDecl = D } } where
    D = Declaration { loc = Loc };
    { module = Mod } = Loc;
    { file = F }  = Mod ) |
  ( { F, { memberDecl = D } } where
    D = MemberDeclaration { loc = Loc };
    { module = Mod } = Loc;
    { file = F }  = Mod ) |
  ( { F, { typeDecl = D } } where
    D = TypeDeclaration { loc = Loc };
    { module = Mod } = Loc;
    { file = F }  = Mod )

type SomeDeclaration = {
  localDecl : Declaration |
  memberDecl : MemberDeclaration |
  typeDecl : TypeDeclaration |
}

# Search for decl by strings, precisely. We might need to store these
predicate SearchByName :
  {
    name : flow.Name,
    string_: string,
    decl : flow.SomeDeclaration
  }
  ({ name = N, string_ = S, decl = { localDecl = D } } where
    D = flow.Declaration { name = N, loc = Loc };
    { module = { file = F } } = Loc;
    flow.FileOfStringModule { F , S }) |
  ({ name = N, string_ = S, decl = { memberDecl = D } } where
    D = flow.MemberDeclaration { name = N, loc = Loc };
    { module = { file = F } } = Loc;
    flow.FileOfStringModule { F , S }) |
  ({ name = N, string_ = S, decl = { typeDecl = D } } where
    D = flow.TypeDeclaration { name = N, loc = Loc };
    { module = { file = F } } = Loc;
    flow.FileOfStringModule { F , S })

# Search by Name and string code for the Module
predicate SearchByModule :
  {
    string_: string,
    name : flow.Name,
    decl : flow.SomeDeclaration
  }
  { S, N, D } where
    StringToFileModule { S, F };
    FileDeclaration { F, D };
    ({ localDecl = { name = N } } |
     { memberDecl = { name = N } } |
     { typeDecl = { name = N }}) = D;

# Lookup a declaration knowing its name and its file
# Should be O(1)
predicate SearchByFileModule :
  {
    file : src.File,
    name : flow.Name,
    decl : flow.SomeDeclaration
  }
  { file = F, name = N, decl = D } where
    ({ localDecl = { name = N } } |
     { memberDecl = { name = N } } |
     { typeDecl = { name = N }}) = D;
    FileDeclaration { F, D };

# For types exported from .flow files the Haste short name is mapped to the
# .flow file via the ModuleTypeExport facts
predicate SearchTypeByModuleExport :
  {
    string_: string,
    name : flow.Name,
    decl : flow.SomeDeclaration
  }
  { S, N, { typeDecl = D } } where
    StringToFileModule { S, F };
    MTE = ModuleTypeExport { module = { file = F } };
    SourceOfTypeExport { MTE, { typeDeclaration = D } };
    { name = N } = D;

# Location of a SomeDeclaration
predicate DeclarationLocation :
  {
    decl: SomeDeclaration,
    file: src.File,
    span: src.ByteSpan,
  }
  ( { decl = { localDecl = D }, file = F, span = S } where
    Declaration { loc = { module = { file = F }, span = S } } = D ) |
  ( { decl = { memberDecl = D }, file = F, span = S } where
    MemberDeclaration { loc = { module = { file = F }, span = S } } = D ) |
  ( { decl = { typeDecl = D }, file = F, span = S } where
    TypeDeclaration { loc = { module = { file = F }, span = S } } = D )

}
