schema codemarkup.11 {
import src.1
import python.3
import code.12
import code.flow.2
import hs.2
import hack.5
import flow.3

#
# Language-generic navigation and search
# - Declarations, spans and src.Files
# - Entity-based , more stable language entities over time
#
# File/location operations
# - FileDirectXRefs
# - FileDeclarations
#
# Entity-level operations
# - EntityUses
# - EntityDeclarations
# - (todo) EntityXRefs (?)
#

# Reference from a span to its declaration site
type DirectXRef =
  {
    target: Declaration,
    source: src.ByteSpan,
  }

type Declaration =
  {
    name: string,
    file: src.File,
    span: src.ByteSpan,
  }

type Annotation =
  {
    span: src.ByteSpan,
    shortName: string,
    linkTo: maybe LinkTo,
    # TODO
    # linksFrom: maybe [LinksFrom],
    # tooltip: maybe string,
  }

type LinkTo =
  {
    localRepo: src.FileLocation |
    # TODO
    # otherRepo: RepoFileLocation |
  }

predicate FlowDeclarationInfo:
  {
    decl: flow.SomeDeclaration,
    name: flow.Name,
    span: src.ByteSpan
  }
  { Decl, Name, Span } where
    (
      { localDecl = D } = Decl;
      { name = Name, loc = { span = Span }} = D
    ) | (
      { memberDecl = D } = Decl;
      { name = Name, loc = { span = Span }} = D
    ) | (
      { typeDecl = D } = Decl;
      { name = Name, loc = { span = Span }} = D
    )

predicate FlowFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  { File, DXRef } where
    FlowFileEntityXRefs { file = File, xref = DXRef }

predicate HackFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  { File, DXRef } where
    HackFileEntityXRefs { file = File, xref = DXRef }

predicate PythonFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, XRef} where
    PythonFileEntityXRefs { file = File, xref = XRef }

predicate HaskellFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, {Decl, Src}} where
  hs.FileXRefMap { file = File, refs = Refs };
  { target = Target, spans = Spans } : hs.XReference = Refs [..];
  Src : src.ByteSpan = Spans [..];
  Target = hs.XRefTarget { definition =  hs.DefinitionName TargetName };
  hs.Definition {hs.DefinitionName TargetName, {TargetFile, TargetSpan}};
  Decl = Declaration {TargetName, TargetFile, TargetSpan};

# Direct references from symbols to their definitions, by file
predicate FileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, DXRef} where
    PythonFileDirectXRefs {File, DXRef} |
    HaskellFileDirectXRefs {File, DXRef} |
    HackFileDirectXRefs {File, DXRef} |
    FlowFileDirectXRefs {File, DXRef};

predicate FileAnnotations:
  {
    file: src.File,
    annotation: Annotation,
  }
  { File, Ann } where
  FileDirectXRefs {
    File, { { name=ShortName, file=DstFile, span=DstSpan }, Source }
  };
  Ann =
    Annotation {
      span = Source,
      shortName = ShortName,
      linkTo = { just = { localRepo = { DstFile, DstSpan } } }
    }

# Declarations, by file
predicate FileDeclarations:
  {
    file: src.File,
    decl: Declaration,
  }
  { File, Decl } where
    FileEntities { file = File, decl = Decl }

# TODO: deprecated
predicate HackFileDeclarations:
  {
    file: src.File,
    declaration : Declaration
  } { F, D } where
    HackResolve { decl = D }; { file = F } = D;

# TODO: deprecated
predicate PythonFileDeclarations:
 {
   file: src.File,
   declaration : Declaration
 } { F, D } where
   PythonResolve { decl = D }; { file = F } = D;

# TODO: deprecated
predicate FlowFileDeclarations:
  {
    file: src.File,
    declaration : Declaration
  } { F, D } where
    FlowResolve { decl = D }; { file = F } = D;

#
# Entity-based associations
#

# File to references to definition, by Declaration,Entity pairs
predicate FileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  {File, DXRef, Ent} where
    HackFileEntityXRefs {File, DXRef, Ent} |
    FlowFileEntityXRefs {File, DXRef, Ent} |
    PythonFileEntityXRefs {File, DXRef, Ent}

# Find references to a language entity
predicate EntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan
  }
  {E, File, Span} where
    HackEntityUses {E, File, Span} |
    FlowEntityUses {E, File, Span} |
    PythonEntityUses {E, File, Span}

# Find entities in a File (and their concrete Declaration)
predicate FileEntities:
  {
    file: src.File,
    decl: Declaration,
    entity: code.Entity,
  }
  { File, Decl, Ent } where
    Resolve { Decl, Ent };
    Decl = Declaration { _, File, _};

# Map a concrete Declaration (span,file) to its language semantic Entity
predicate Resolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { D, E } where
    HackResolve {D, E} |
    PythonResolve {D, E} |
    FlowResolve {D, E}

# TODO this for Python, FlowXRefDeclInfo for Flow.
# Just abstracts the Decl to Entity with tag mappings
predicate EntityToDeclaration:
  {
    entity: code.Entity,
    decl: Declaration,
  }
  {Ent, Decl} where
  { python = { decl = PyDecl }} = Ent;
  (
    { cls = D } = PyDecl;
    D = python.ClassDeclaration { name = PyName };
  ) | (
    { func = D } = PyDecl;
    D = python.FunctionDeclaration { name = PyName };
  ) | (
    { variable = D } = PyDecl;
    D = python.VariableDeclaration { name = PyName };
  ) | (
    { imp = D } = PyDecl;
    D = python.ImportStatement { from_name = PyName };
  ) ;
  PyName = python.Name Name;
  python.DeclarationLocation {PyDecl, File, Span};
  Decl = Declaration {Name, File, Span};

#
# Language instantiations of the entity ops
#

predicate HackFileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  { File, { Decl, Src }, Entity } where
    hack.FileXRefs { file = File, xrefs = XRefs };
    hack.XRef { target = { declaration = D }, ranges = Uses } = XRefs[..];
    hack.DeclarationName D -> (hack.Name TargetName);
    hack.DeclarationLocation { declaration = D, file = TargetFile, span = TargetSpan };
    Decl = Declaration { TargetName, TargetFile, TargetSpan };
    Sources = prim.relToAbsByteSpans Uses;
    Src = Sources[..];
    Entity = code.Entity { hack = { decl = D } };

# All cross-references we want to expose in the file
predicate FlowFileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  { File, XRef, { flow = Entity } } where
    FlowFileReferenceEntityXRef { File, XRef, Entity } |
    FlowFileImportDeclEntityXRef { File, XRef, Entity }

# Cross-references from occurrences.
#
# References in the Flow index point to the local import declaration
# in the file.  To resolve these to the remote reference:
#
#  * For each reference in the file (flow.FileXRef)
#  * emit a DirectXRef to its target
#  * also, if the target is a flow.ImportDeclaration
#  * find the source of the import, and emit a DirectXRef to that
#
# And do the same for type declarations.
#
# This will result in two DirectXRefs for each non-local reference,
# one pointing to the import declaration and another to the non-local
# target. The client can decide which one(s) it wants.
#
predicate FlowFileReferenceEntityXRef:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.flow.Entity,
  }
  { File, {Decl, Src}, Entity } where
    flow.FileXRef { file = File, ref = XRef };
    flow.FlowXRefDeclInfo { XRef, SrcLoc, Name, TargetLoc, D };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;
    (
      # TODO: should be able to inline M, but the optimiser got it wrong
      { module = M, span = TargetSpan } = TargetLoc;
      { file = TargetFile } = M;
      { decl = D } = Entity;
    ) | (
      { localRef = { declaration = LocalD } } = XRef;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
    ) | (
      { typeRef = { typeDeclaration = T } } = XRef;
      flow.FlowTypeImportXRef { T, Entity, TargetFile, TargetSpan };
    );
    Decl = Declaration { Str, TargetFile, TargetSpan };

# Cross-references from import declarations.
#
# We want to hyperlink the identifiers in an import declaration to the
# source of the import:
#
#   * For each declaration in the file (flow.FileDeclaration)
#   * If it is an import declaraiton, find the source (reusing FlowImportXRef)
#
# and do the same for type declarations (FlowTypeImportXRef).
#
predicate FlowFileImportDeclEntityXRef:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.flow.Entity,
  }
  { File, { Decl, Src }, Entity } where
    flow.FileDeclaration { File, D };
    (
      { localDecl = LocalD } = D;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = LocalD;
    ) | (
      { typeDecl = TypeD } = D;
      flow.FlowTypeImportXRef { TypeD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = TypeD;
    );
    Decl = Declaration { Str, TargetFile, TargetSpan };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;

predicate PythonFileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  {File, {Decl, Src}, Entity} where
  {PyDecl, Src} = (
    python.DeclarationsByFile {
      file = File,
      span = Src,
      declaration = { imp = { from_name = TargetName } },
    };
    python.DeclarationWithName { name = TargetName, declaration = TargetDecl};
    {TargetDecl, Src}
  )
  |
  (
    python.DirectXRefsByFile {File, XRef};
    XRef
  )
  ;
  Entity = code.Entity { python = { decl = PyDecl } };
  EntityToDeclaration { entity = Entity, decl = Decl};

predicate HackEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { hack = { decl = D } }, File, Span } where
    hack.TargetUses { target = { declaration = D }, file = File, uses = Uses };
    Spans = prim.relToAbsByteSpans Uses;
    Span = Spans[..];

predicate FlowEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { flow = Entity }, File, Span } where
    flow.FlowEntityUsesAll { Entity, File, Span };

predicate PythonEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { python = { decl = D } }, File, Span } where
  python.DeclarationUses { declaration = D, file = File, span = Span}

predicate HackDeclarationUses:
  {
    target: hack.Declaration,
    file: src.File,
    span: src.ByteSpan,
  }
  { D, File, Span } where
    hack.TargetUses { target = { declaration = D }, file = File, uses = Uses };
    Spans = prim.relToAbsByteSpans Uses;
    Span = Spans[..];

predicate HackResolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { { Name, File, Span } , E } where
    hack.FileDeclarations { file = File, declarations = Ds };
    D = Ds[..];
    hack.DeclarationName D -> (hack.Name Name);
    hack.DeclarationLocation { declaration = D, file = File, span = Span };
    E = code.Entity { hack = { decl = D } };

predicate PythonResolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { { Name, File, Span } , E } where
    python.DeclarationsByFile { File, Span, D };
    python.DeclarationToName D -> (Name : string);
    E = code.Entity { python = { decl = D } };

predicate FlowResolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { { NameStr, File, Span } , E } where
    flow.FileDeclaration { File, D };
    FlowDeclarationInfo { D, Name, Span };
    Name = flow.Name NameStr ;
    E = code.Entity { flow = { decl = D } };

}

schema codemarkup.12 {
import src.1
import python.3
# import code.12 not ready
import code.11
import code.flow.2
import hs.2
# impport hack.5 not ready
import hack.4
import flow.3
import cxx1.4

# Deprecated types

# deprecated
type Declaration =
  {
    name: string,
    file: src.File,
    span: src.ByteSpan,
  }

# deprecated
type DirectXRef =
  {
    target: Declaration,
    source: src.ByteSpan,
  }

# deprecated: shiny xrefs
type Annotation =
  {
    span: src.ByteSpan,
    shortName: string,
    linkTo: maybe LinkTo,
  }

type LinkTo =
  {
    localRepo: src.FileLocation |
  }

# Deprecate Shiny xref API

# deprecated
# usage: https://fburl.com/scuba/glean_server/9oiuyblv
predicate FileAnnotations:
  {
    file: src.File,
    annotation: Annotation,
  }
  { File, Ann } where
  FileDirectXRefs {
    File, { { name=ShortName, file=DstFile, span=DstSpan }, Source }
  };
  Ann =
    Annotation {
      span = Source,
      shortName = ShortName,
      linkTo = { just = { localRepo = { DstFile, DstSpan } } }
    }

# deprecated, used only by FileAnnotations
predicate FileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  ({ File, DirectXRef } where
    FileEntityXRefLocations { File, XRef, _ };
    ToLegacyXRef {XRef, DirectXRef}) |
  ({ File, DirectXRef } where
    HaskellFileDirectXRefs { File, DirectXRef })

# deprecated, used only by FileAnnotations via FileDirectXRefs
predicate HaskellFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, {Decl, Src}} where
  hs.FileXRefMap { file = File, refs = Refs };
  { target = Target, spans = Spans } : hs.XReference = Refs [..];
  Src : src.ByteSpan = Spans [..];
  Target = hs.XRefTarget { definition =  hs.DefinitionName TargetName };
  hs.Definition {hs.DefinitionName TargetName, {TargetFile, TargetSpan}};
  Decl = Declaration {TargetName, TargetFile, TargetSpan};

# Deprecated language-agnostic API (v2)

# deprecated
# usage: https://fburl.com/scuba/glean_server/ikx3jonh
predicate FileEntities:
  {
    file: src.File,
    decl: Declaration,
    entity: code.Entity,
  }
  { File, { Name, File, Span }, Entity} where
    FileEntityLocations { File, { Name, File, { span = Span }}, Entity }

# deprecated
# usage: https://fburl.com/scuba/glean_server/klkte66n
predicate Resolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { { Name, File, Span }, Entity } where
    ResolveLocation { { Name, File, { span = Span }}, Entity }

# deprecated
# usage: https://fburl.com/scuba/glean_server/fjkzcdgp
predicate FileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  { File, DirectXRef, Entity } where
    FileEntityXRefLocations { File, XRef, Entity };
    ToLegacyXRef {XRef, DirectXRef};

# Compat shims for old xref format (deprecated)
predicate ToLegacyXRef:
  {
    from: XRefLocation,
    to: DirectXRef
  }
  { { FromTarget, FromSource } , DirectXRef } where
    DirectXRef = (
      { Name, TargetFile, {span = TargetSpan} } = FromTarget;
      { span = Span } = FromSource;
      {{ Name, TargetFile, TargetSpan}, Span };
    )

#
# Public API
#

# Public types

# Within a file, the type of symbol locations
type RangeSpan =
  {
    span : src.ByteSpan |
    range : src.Range # cxx compat
  }

# Symbol locations within a repo
type Location =
  {
    name: string,
    file: src.File,
    location : RangeSpan,
  }

# XRefs from source to target declaration or definition
type XRefLocation =
  {
    target: Location,
    source: RangeSpan
  }

# Public language-agnostic API

# All entities defined in a src.File and their locations
predicate FileEntityLocations:
  {
    file: src.File,
    location: Location,
    entity: code.Entity,
  }
  { File, Location, Entity } where
    ResolveLocation { Location, Entity };
    Location { file = File } = Location;

# Map a location to the Entity declared there
predicate ResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { Location, Entity } where
    HackResolveLocation { Location, Entity } |
    PythonResolveLocation { Location, Entity } |
    FlowResolveLocation { Location, Entity } |
    CxxResolveLocation { Location, Entity }

# Finding xrefs. All references in a file and their targets
predicate FileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, Entity } where
    HackFileEntityXRefLocations { File, XRef, Entity } |
    FlowFileEntityXRefLocations { File, XRef, Entity } |
    PythonFileEntityXRefLocations { File, XRef, Entity } |
    CxxFileEntityXRefLocations { File, XRef, Entity }

# Find references to a language entity
predicate EntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan
  }
  {Entity, File, Span} where
    HackEntityUses { Entity, File, Span } |
    FlowEntityUses { Entity, File, Span } |
    PythonEntityUses { Entity, File, Span } |
    CxxEntityUses { Entity, File, Span }

# Private language instances

# Resolving locations to entities

predicate HackResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Name, File, { span = Span } }, Entity } where
    hack.FileDeclarations { file = File, declarations = Ds };
    Decl = Ds[..];
# hack.5
#    hack.DeclarationName Decl -> (hack.Name Name);
# hack.4
    hack.DeclarationName { declaration = Decl, name = hack.Name Name };
    hack.DeclarationLocation { declaration = Decl, file = File, span = Span };
    Entity = code.Entity { hack = { decl = Decl } };

predicate PythonResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Name, File, { span = Span } }, Entity } where
    python.DeclarationsByFile { File, Span, Decl };
    python.DeclarationToName Decl -> (Name : string);
    Entity = code.Entity { python = { decl = Decl } };

predicate FlowResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { NameStr, File, { span = Span } }, Entity } where
    flow.FileDeclaration { File, Decl };
    flow.DeclarationNameSpan { Decl, Name, Span };
    Name = flow.Name NameStr ;
    Entity = code.Entity { flow = { decl = Decl } };

predicate CxxResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Str, File, { range = Range } }, Entity } where
    cxx1.Trace { file = File, declarations = cxx1.Declarations Decls };
    Decl = Decls[..];
    cxx1.DeclarationLocation { Decl, Range, Name };
    cxx1.Name Str = Name;
    Entity = code.Entity { cxx = { decl = Decl } };

# Finding references in a file

predicate HackFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, { Location, { span = Src } }, Entity } where
    hack.FileXRefs { file = File, xrefs = XRefs };
    hack.XRef { target = { declaration = D }, ranges = Uses } = XRefs[..];
# hack.4
    hack.DeclarationName { declaration = D, name = hack.Name TargetName };
# hack.5
#    hack.DeclarationName D -> (hack.Name TargetName);
    hack.DeclarationLocation { declaration = D, file = TargetFile, span = TargetSpan };
    Location = Location { TargetName, TargetFile, { span = TargetSpan }};
    Sources = prim.relToAbsByteSpans Uses;
    Src = Sources[..];
    Entity = code.Entity { hack = { decl = D } };

predicate FlowFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, { flow = Entity } } where
    FlowFileReferenceEntityXRefLocations { File, XRef, Entity } |
    FlowFileImportDeclEntityXRefLocations { File, XRef, Entity }

# Flow cross-references from occurrences.
#
# References in the Flow index point to the local import declaration
# in the file.  To resolve these to the remote reference:
#
#  * For each reference in the file (flow.FileXRef)
#  * emit a DirectXRef to its target
#  * also, if the target is a flow.ImportDeclaration
#  * find the source of the import, and emit a DirectXRef to that
#
# And do the same for type declarations.
#
# This will result in two DirectXRefs for each non-local reference,
# one pointing to the import declaration and another to the non-local
# target. The client can decide which one(s) it wants.
#
predicate FlowFileReferenceEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.flow.Entity,
  }
  { File, {Location, { span = Src }}, Entity } where
    flow.FileXRef { file = File, ref = XRef };
    flow.FlowXRefDeclInfo { XRef, SrcLoc, Name, TargetLoc, D };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;
    (
      # TODO: should be able to inline M, but the optimiser got it wrong
      { module = M, span = TargetSpan } = TargetLoc;
      { file = TargetFile } = M;
      { decl = D } = Entity;
    ) | (
      { localRef = { declaration = LocalD } } = XRef;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
    ) | (
      { typeRef = { typeDeclaration = T } } = XRef;
      flow.FlowTypeImportXRef { T, Entity, TargetFile, TargetSpan };
    );
    Location = Location { Str, TargetFile, { span = TargetSpan }}

# Flow cross-references from import declarations.
#
# We want to hyperlink the identifiers in an import declaration to the
# source of the import:
#
# * For each declaration in the file (flow.FileDeclaration)
# * If it is an import declaraiton, find the source (reusing FlowImportXRef)
#
# and do the same for type declarations (FlowTypeImportXRef).
#
predicate FlowFileImportDeclEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.flow.Entity,
  }
  { File, { Location, { span = Src } }, Entity } where
    flow.FileDeclaration { File, D };
    (
      { localDecl = LocalD } = D;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = LocalD;
    ) | (
      { typeDecl = TypeD } = D;
      flow.FlowTypeImportXRef { TypeD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = TypeD;
    );
    Location = Location { Str, TargetFile, { span = TargetSpan } };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;

predicate PythonFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  {File, {Location, { span = Src }}, Entity} where
  {PyDecl, Src} = (
    python.DeclarationsByFile {
      file = File,
      span = Src,
      declaration = { imp = { from_name = TargetName } },
    };
    python.DeclarationWithName { name = TargetName, declaration = TargetDecl};
    {TargetDecl, Src}
  ) | (
    python.DirectXRefsByFile {File, XRef};
    XRef
  );
  Entity = code.Entity { python = { decl = PyDecl } };
  PythonEntityToDeclaration { entity = Entity, decl = Decl};
  { Name, TargetFile, TargetSpan } = Decl;
  { Name, TargetFile, { span = TargetSpan }} = Location;

# N.B. uses deprecated types
predicate PythonEntityToDeclaration:
  {
    entity: code.Entity,
    decl: Declaration,
  }
  {Ent, Decl} where
  { python = { decl = PyDecl }} = Ent;
  (
    { cls = D } = PyDecl;
    D = python.ClassDeclaration { name = PyName };
  ) | (
    { func = D } = PyDecl;
    D = python.FunctionDeclaration { name = PyName };
  ) | (
    { variable = D } = PyDecl;
    D = python.VariableDeclaration { name = PyName };
  ) | (
    { imp = D } = PyDecl;
    D = python.ImportStatement { from_name = PyName };
  ) ;
  PyName = python.Name Name;
  python.DeclarationLocation {PyDecl, File, Span};
  Decl = Declaration {Name, File, Span};

predicate CxxFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, Entity } where
    XMap = cxx1.FileXRefMap { File, Fixeds, _ };
    cxx1.FileXRefs { XMap, _ };

    # .. go through fixed declarations
    ({ XRef, Entity } where
      cxx1.FixedXRef { { declaration = Decl }, Spans } = Fixeds[..];
      cxx1.DeclarationLocation { Decl, Range, cxx1.Name Name };
      Span = Spans[..];
      { file = TargetFile } = Range;
      { { Name, TargetFile, { range = Range } }, { span = Span }} = XRef;
      code.Entity { cxx = { decl = Decl }} = Entity;
    )
    # .. go through variable
    # need to zip xref target Externals with Variable at same location
    # .. can't zip..
    #  (XRefTarget, Span) = zip Externals[..] Variables[..];
    #  CxxXRefTargetEntity { XRefTarget, Entity }
    #  { { Name, TargetFile, { range = Range } }, { span = Span }} = XRef;

# Finding references to a definition
predicate CxxXRefTargetEntity:
  {
    target: cxx1.XRefTarget,
    entity: code.Entity,
  }
  ({ Target, { cxx = { decl = D } } }  where
    { declaration = D } = Target) |
  ({ Target, { cxx = { enumerator = E } } }  where
    { enumerator = E } = Target)
  # recursive to handle indirect xrefs
  # todo try unrolling 1 or 2 levels
  # ({ Target, Entity }  where
  #  { indirect = { target = X } } = Target;
  #  CxxXRefTargetEntity { X, Entity })

predicate HackEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { hack = { decl = D } }, File, Span } where
    hack.TargetUses { target = { declaration = D }, file = File, uses = Uses };
    Spans = prim.relToAbsByteSpans Uses;
    Span = Spans[..];

predicate FlowEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { flow = Entity }, File, Span } where
    flow.FlowEntityUsesAll { Entity, File, Span };

predicate PythonEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { python = { decl = D } }, File, Span } where
  python.DeclarationUses { declaration = D, file = File, span = Span}

predicate CxxEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  ({ { cxx = { decl = D } }, File, Span } where
    cxx1.TargetUses { { declaration = D } , File, Spans };
    Span = Spans[..]) |
  ({ { cxx = { enumerator = E } }, File, Span } where
    cxx1.TargetUses { { enumerator = E } , File, Spans };
    Span = Spans[..])

}

schema codemarkup.13 {
import src.1
import python.3
import code.12
import code.flow.2
import hs.2
import hack.5
import flow.3
import cxx1.4

# Deprecated types

# deprecated
type Declaration =
  {
    name: string,
    file: src.File,
    span: src.ByteSpan,
  }

# deprecated
type DirectXRef =
  {
    target: Declaration,
    source: src.ByteSpan,
  }

# deprecated: shiny xrefs
type Annotation =
  {
    span: src.ByteSpan,
    shortName: string,
    linkTo: maybe LinkTo,
  }

type LinkTo =
  {
    localRepo: src.FileLocation |
  }

# Deprecate Shiny xref API

# deprecated
# usage: https://fburl.com/scuba/glean_server/9oiuyblv
predicate FileAnnotations:
  {
    file: src.File,
    annotation: Annotation,
  }
  { File, Ann } where
  FileDirectXRefs {
    File, { { name=ShortName, file=DstFile, span=DstSpan }, Source }
  };
  Ann =
    Annotation {
      span = Source,
      shortName = ShortName,
      linkTo = { just = { localRepo = { DstFile, DstSpan } } }
    }

# deprecated, used only by FileAnnotations
predicate FileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  ({ File, DirectXRef } where
    FileEntityXRefLocations { File, XRef, _ };
    ToLegacyXRef {XRef, DirectXRef}) |
  ({ File, DirectXRef } where
    HaskellFileDirectXRefs { File, DirectXRef })

# deprecated, used only by FileAnnotations via FileDirectXRefs
predicate HaskellFileDirectXRefs:
  {
    file: src.File,
    xref: DirectXRef,
  }
  {File, {Decl, Src}} where
  hs.FileXRefMap { file = File, refs = Refs };
  { target = Target, spans = Spans } : hs.XReference = Refs [..];
  Src : src.ByteSpan = Spans [..];
  Target = hs.XRefTarget { definition =  hs.DefinitionName TargetName };
  hs.Definition {hs.DefinitionName TargetName, {TargetFile, TargetSpan}};
  Decl = Declaration {TargetName, TargetFile, TargetSpan};

# Deprecated language-agnostic API (v2)

# deprecated
# usage: https://fburl.com/scuba/glean_server/ikx3jonh
predicate FileEntities:
  {
    file: src.File,
    decl: Declaration,
    entity: code.Entity,
  }
  { File, { Name, File, Span }, Entity} where
    FileEntityLocations { File, { Name, File, { span = Span }}, Entity }

# deprecated
# usage: https://fburl.com/scuba/glean_server/klkte66n
predicate Resolve:
  {
    decl: Declaration,
    entity: code.Entity,
  }
  { { Name, File, Span }, Entity } where
    ResolveLocation { { Name, File, { span = Span }}, Entity }

# deprecated
# usage: https://fburl.com/scuba/glean_server/fjkzcdgp
predicate FileEntityXRefs:
  {
    file: src.File,
    xref: DirectXRef,
    entity: code.Entity,
  }
  { File, DirectXRef, Entity } where
    FileEntityXRefLocations { File, XRef, Entity };
    ToLegacyXRef {XRef, DirectXRef};

# Compat shims for old xref format (deprecated)
predicate ToLegacyXRef:
  {
    from: XRefLocation,
    to: DirectXRef
  }
  { { FromTarget, FromSource } , DirectXRef } where
    DirectXRef = (
      { Name, TargetFile, {span = TargetSpan} } = FromTarget;
      { span = Span } = FromSource;
      {{ Name, TargetFile, TargetSpan}, Span };
    )

#
# Public API
#

# Public types

# Within a file, the type of symbol locations
type RangeSpan =
  {
    span : src.ByteSpan |
    range : src.Range # cxx compat
  }

# Symbol locations within a repo
type Location =
  {
    name: string,
    file: src.File,
    location : RangeSpan,
  }

# XRefs from source to target declaration or definition
type XRefLocation =
  {
    target: Location,
    source: RangeSpan
  }

# Public language-agnostic API

# All entities defined in a src.File and their locations
predicate FileEntityLocations:
  {
    file: src.File,
    location: Location,
    entity: code.Entity,
  }
  { File, Location, Entity } where
    ResolveLocation { Location, Entity };
    Location { file = File } = Location;

# Map a location to the Entity declared there
predicate ResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { Location, Entity } where
    HackResolveLocation { Location, Entity } |
    PythonResolveLocation { Location, Entity } |
    FlowResolveLocation { Location, Entity } |
    CxxResolveLocation { Location, Entity }

# Finding xrefs. All references in a file and their targets
predicate FileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, Entity } where
    HackFileEntityXRefLocations { File, XRef, Entity } |
    FlowFileEntityXRefLocations { File, XRef, Entity } |
    PythonFileEntityXRefLocations { File, XRef, Entity } |
    CxxFileEntityXRefLocations { File, XRef, Entity }

# Find references to a language entity
predicate EntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan
  }
  {Entity, File, Span} where
    HackEntityUses { Entity, File, Span } |
    FlowEntityUses { Entity, File, Span } |
    PythonEntityUses { Entity, File, Span } |
    CxxEntityUses { Entity, File, Span }

# Private language instances

# Resolving locations to entities

predicate HackResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Name, File, { span = Span } }, Entity } where
    hack.FileDeclarations { file = File, declarations = Ds };
    Decl = Ds[..];
    hack.DeclarationName Decl -> (hack.Name Name);
    hack.DeclarationLocation { declaration = Decl, file = File, span = Span };
    Entity = code.Entity { hack = { decl = Decl } };

predicate PythonResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Name, File, { span = Span } }, Entity } where
    python.DeclarationsByFile { File, Span, Decl };
    python.DeclarationToName Decl -> (Name : string);
    Entity = code.Entity { python = { decl = Decl } };

predicate FlowResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { NameStr, File, { span = Span } }, Entity } where
    flow.FileDeclaration { File, Decl };
    flow.DeclarationNameSpan { Decl, Name, Span };
    Name = flow.Name NameStr ;
    Entity = code.Entity { flow = { decl = Decl } };

predicate CxxResolveLocation:
  {
    location: Location,
    entity: code.Entity,
  }
  { { Str, File, { range = Range } }, Entity } where
    cxx1.Trace { file = File, declarations = cxx1.Declarations Decls };
    Decl = Decls[..];
    cxx1.DeclarationLocation { Decl, Range, Name };
    cxx1.Name Str = Name;
    Entity = code.Entity { cxx = { decl = Decl } };

# Finding references in a file

predicate HackFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, { Location, { span = Src } }, Entity } where
    hack.FileXRefs { file = File, xrefs = XRefs };
    hack.XRef { target = { declaration = D }, ranges = Uses } = XRefs[..];
    hack.DeclarationName D -> (hack.Name TargetName);
    hack.DeclarationLocation { declaration = D, file = TargetFile, span = TargetSpan };
    Location = Location { TargetName, TargetFile, { span = TargetSpan }};
    Sources = prim.relToAbsByteSpans Uses;
    Src = Sources[..];
    Entity = code.Entity { hack = { decl = D } };

predicate FlowFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, { flow = Entity } } where
    FlowFileReferenceEntityXRefLocations { File, XRef, Entity } |
    FlowFileImportDeclEntityXRefLocations { File, XRef, Entity }

# Flow cross-references from occurrences.
#
# References in the Flow index point to the local import declaration
# in the file.  To resolve these to the remote reference:
#
#  * For each reference in the file (flow.FileXRef)
#  * emit a DirectXRef to its target
#  * also, if the target is a flow.ImportDeclaration
#  * find the source of the import, and emit a DirectXRef to that
#
# And do the same for type declarations.
#
# This will result in two DirectXRefs for each non-local reference,
# one pointing to the import declaration and another to the non-local
# target. The client can decide which one(s) it wants.
#
predicate FlowFileReferenceEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.flow.Entity,
  }
  { File, {Location, { span = Src }}, Entity } where
    flow.FileXRef { file = File, ref = XRef };
    flow.FlowXRefDeclInfo { XRef, SrcLoc, Name, TargetLoc, D };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;
    (
      # TODO: should be able to inline M, but the optimiser got it wrong
      { module = M, span = TargetSpan } = TargetLoc;
      { file = TargetFile } = M;
      { decl = D } = Entity;
    ) | (
      { localRef = { declaration = LocalD } } = XRef;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
    ) | (
      { typeRef = { typeDeclaration = T } } = XRef;
      flow.FlowTypeImportXRef { T, Entity, TargetFile, TargetSpan };
    );
    Location = Location { Str, TargetFile, { span = TargetSpan }}

# Flow cross-references from import declarations.
#
# We want to hyperlink the identifiers in an import declaration to the
# source of the import:
#
# * For each declaration in the file (flow.FileDeclaration)
# * If it is an import declaraiton, find the source (reusing FlowImportXRef)
#
# and do the same for type declarations (FlowTypeImportXRef).
#
predicate FlowFileImportDeclEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.flow.Entity,
  }
  { File, { Location, { span = Src } }, Entity } where
    flow.FileDeclaration { File, D };
    (
      { localDecl = LocalD } = D;
      flow.FlowImportXRef { LocalD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = LocalD;
    ) | (
      { typeDecl = TypeD } = D;
      flow.FlowTypeImportXRef { TypeD, Entity, TargetFile, TargetSpan };
      { name = Name, loc = SrcLoc } = TypeD;
    );
    Location = Location { Str, TargetFile, { span = TargetSpan } };
    Name = flow.Name Str;
    { span = Src } = SrcLoc;

predicate PythonFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  {File, {Location, { span = Src }}, Entity} where
  {PyDecl, Src} = (
    python.DeclarationsByFile {
      file = File,
      span = Src,
      declaration = { imp = { from_name = TargetName } },
    };
    python.DeclarationWithName { name = TargetName, declaration = TargetDecl};
    {TargetDecl, Src}
  ) | (
    python.DirectXRefsByFile {File, XRef};
    XRef
  );
  Entity = code.Entity { python = { decl = PyDecl } };
  PythonEntityToDeclaration { entity = Entity, decl = Decl};
  { Name, TargetFile, TargetSpan } = Decl;
  { Name, TargetFile, { span = TargetSpan }} = Location;

# N.B. uses deprecated types
predicate PythonEntityToDeclaration:
  {
    entity: code.Entity,
    decl: Declaration,
  }
  {Ent, Decl} where
  { python = { decl = PyDecl }} = Ent;
  (
    { cls = D } = PyDecl;
    D = python.ClassDeclaration { name = PyName };
  ) | (
    { func = D } = PyDecl;
    D = python.FunctionDeclaration { name = PyName };
  ) | (
    { variable = D } = PyDecl;
    D = python.VariableDeclaration { name = PyName };
  ) | (
    { imp = D } = PyDecl;
    D = python.ImportStatement { from_name = PyName };
  ) ;
  PyName = python.Name Name;
  python.DeclarationLocation {PyDecl, File, Span};
  Decl = Declaration {Name, File, Span};

predicate CxxFileEntityXRefLocations:
  {
    file: src.File,
    xref: XRefLocation,
    entity: code.Entity,
  }
  { File, XRef, Entity } where
    XMap = cxx1.FileXRefMap { File, Fixeds, _ };
    cxx1.FileXRefs { XMap, _ };

    # .. go through fixed declarations
    ({ XRef, Entity } where
      cxx1.FixedXRef { { declaration = Decl }, Spans } = Fixeds[..];
      cxx1.DeclarationLocation { Decl, Range, cxx1.Name Name };
      Span = Spans[..];
      { file = TargetFile } = Range;
      { { Name, TargetFile, { range = Range } }, { span = Span }} = XRef;
      code.Entity { cxx = { decl = Decl }} = Entity;
    )
    # .. go through variable
    # need to zip xref target Externals with Variable at same location
    # .. can't zip..
    #  (XRefTarget, Span) = zip Externals[..] Variables[..];
    #  CxxXRefTargetEntity { XRefTarget, Entity }
    #  { { Name, TargetFile, { range = Range } }, { span = Span }} = XRef;

# Finding references to a definition
predicate CxxXRefTargetEntity:
  {
    target: cxx1.XRefTarget,
    entity: code.Entity,
  }
  ({ Target, { cxx = { decl = D } } }  where
    { declaration = D } = Target) |
  ({ Target, { cxx = { enumerator = E } } }  where
    { enumerator = E } = Target)
  # recursive to handle indirect xrefs
  # todo try unrolling 1 or 2 levels
  # ({ Target, Entity }  where
  #  { indirect = { target = X } } = Target;
  #  CxxXRefTargetEntity { X, Entity })

predicate HackEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { hack = { decl = D } }, File, Span } where
    hack.TargetUses { target = { declaration = D }, file = File, uses = Uses };
    Spans = prim.relToAbsByteSpans Uses;
    Span = Spans[..];

predicate FlowEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { flow = Entity }, File, Span } where
    flow.FlowEntityUsesAll { Entity, File, Span };

predicate PythonEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  { { python = { decl = D } }, File, Span } where
  python.DeclarationUses { declaration = D, file = File, span = Span}

predicate CxxEntityUses:
  {
    target: code.Entity,
    file: src.File,
    span: src.ByteSpan,
  }
  ({ { cxx = { decl = D } }, File, Span } where
    cxx1.TargetUses { { declaration = D } , File, Spans };
    Span = Spans[..]) |
  ({ { cxx = { enumerator = E } }, File, Span } where
    cxx1.TargetUses { { enumerator = E } , File, Spans };
    Span = Spans[..])

}
