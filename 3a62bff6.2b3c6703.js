(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{129:function(e,a,n){"use strict";n.d(a,"a",(function(){return p})),n.d(a,"b",(function(){return h}));var t=n(0),i=n.n(t);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function c(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),o=function(e){var a=i.a.useContext(b),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},p=function(e){var a=o(e.components);return i.a.createElement(b.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},d=i.a.forwardRef((function(e,a){var n=e.components,t=e.mdxType,l=e.originalType,r=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=o(n),d=t,h=p["".concat(r,".").concat(d)]||p[d]||m[d]||l;return n?i.a.createElement(h,s(s({ref:a},b),{},{components:n})):i.a.createElement(h,s({ref:a},b))}));function h(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var l=n.length,r=new Array(l);r[0]=d;var s={};for(var c in a)hasOwnProperty.call(a,c)&&(s[c]=a[c]);s.originalType=e,s.mdxType="string"==typeof e?e:t,r[1]=s;for(var b=2;b<l;b++)r[b]=n[b];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},87:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",(function(){return c})),n.d(a,"metadata",(function(){return b})),n.d(a,"toc",(function(){return o})),n.d(a,"default",(function(){return m}));var t=n(3),i=n(7),l=(n(0),n(129)),r=n(39),s=["components"],c={id:"guide",title:"Angle Guide",sidebar_label:"Guide"},b={unversionedId:"angle/guide",id:"angle/guide",isDocsHomePage:!1,title:"Angle Guide",description:"The following guide will explain Angle from first principles, leading you through from simple queries to more complex ones.",source:"@site/../docs/angle/guide.md",slug:"/angle/guide",permalink:"/docs/angle/guide",version:"current",sidebar_label:"Guide",sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/docs/angle/intro"},next:{title:"Query Efficiency",permalink:"/docs/angle/efficiency"}},o=[{value:"Just the facts",id:"just-the-facts",children:[]},{value:"Matching nested facts",id:"matching-nested-facts",children:[]},{value:"Union types",id:"union-types",children:[]},{value:"Maybe",id:"maybe",children:[]},{value:"Or-patterns",id:"or-patterns",children:[]},{value:"More complex queries",id:"more-complex-queries",children:[]},{value:"Statements",id:"statements",children:[]},{value:"Arrays",id:"arrays",children:[]},{value:"String prefix",id:"string-prefix",children:[]},{value:"Tuples",id:"tuples",children:[]},{value:"Enums and bool",id:"enums-and-bool",children:[]}],p={toc:o};function m(e){var a=e.components,n=Object(i.a)(e,s);return Object(l.b)("wrapper",Object(t.a)({},p,n,{components:a,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The following guide will explain Angle from first principles, leading you through from simple queries to more complex ones."),Object(l.b)("p",null,"If you want to try the examples for yourself, or experiment with\nchanges to the example schema, you should first follow the\ninstructions in ",Object(l.b)("a",{parentName:"p",href:"../walkthrough"},"Walkthrough")," to get set up."),Object(l.b)(r.FbInternalOnly,{mdxType:"FbInternalOnly"},Object(l.b)("p",null,"There are also ",Object(l.b)("a",{parentName:"p",href:"https://www.internalfb.com/intern/wiki/Glean/Query/Angle/Angle_examples/"},"examples of using Angle")," to query real data.")),Object(l.b)("h2",{id:"just-the-facts"},"Just the facts"),Object(l.b)("p",null,"Data in Glean is described by a ",Object(l.b)("em",{parentName:"p"},"schema"),", which we normally put in a file with the extension ",Object(l.b)("inlineCode",{parentName:"p"},"angle"),". For the purposes of this guide we\u2019ll use the example schema in ",Object(l.b)("inlineCode",{parentName:"p"},"example.angle"),". Full details about defining schemas can be found in ",Object(l.b)("a",{parentName:"p",href:"../schema/basic"},"Schemas"),". The ",Object(l.b)("inlineCode",{parentName:"p"},"example.angle")," file contains a schema definition like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"schema example.1 {\n\n# definitions go here\n\n}\n")),Object(l.b)("p",null,"This says we\u2019re defining a schema called ",Object(l.b)("inlineCode",{parentName:"p"},"example"),", with version 1."),Object(l.b)("p",null,"The schema contains definitions for ",Object(l.b)("em",{parentName:"p"},"predicates"),". A predicate is the type of ",Object(l.b)("em",{parentName:"p"},"facts"),", which are the individual pieces of information that Glean stores.  Our example schema models a simplified class hierarchy for an object-oriented language, starting with a predicate for a ",Object(l.b)("inlineCode",{parentName:"p"},"Class"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Class :\n  {\n     name : string,\n     line : nat,\n  }\n")),Object(l.b)("p",null,"This says that the facts of ",Object(l.b)("inlineCode",{parentName:"p"},"Class")," are records with two fields, a ",Object(l.b)("inlineCode",{parentName:"p"},"name")," field which contains a ",Object(l.b)("inlineCode",{parentName:"p"},"string"),", and a ",Object(l.b)("inlineCode",{parentName:"p"},"line")," field which contains a ",Object(l.b)("inlineCode",{parentName:"p"},"nat")," (\u201cnat\u201d is short for \u201cnatural number\u201d, which is limited to 64 bits in Glean)."),Object(l.b)("p",null,"The simplest type of Angle query is one that just selects facts from\nthe database that match a pattern.  For our first Angle query, let\u2019s\nfind a class by its name:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},'facts> example.Class { name = "Pet" }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\n\n1 results, 1 facts, 4.61ms, 117632 bytes, 677 compiled bytes\n')),Object(l.b)("p",null,"(The last line contains statistics about query performance from Glean; I\u2019ll leave this out in the rest of the examples.)"),Object(l.b)("p",null,"What\u2019s going on here?"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The query consists of the ",Object(l.b)("em",{parentName:"li"},"predicate name")," ",Object(l.b)("inlineCode",{parentName:"li"},"example.Class")," followed by a ",Object(l.b)("em",{parentName:"li"},"pattern")," ",Object(l.b)("inlineCode",{parentName:"li"},'{ name = "Pet" }')),Object(l.b)("li",{parentName:"ul"},"Note that when we refer to a predicate in a query, the name is ",Object(l.b)("em",{parentName:"li"},"qualified")," by prefixing the schema name, so it\u2019s ",Object(l.b)("inlineCode",{parentName:"li"},"example.Class")," rather than just ",Object(l.b)("inlineCode",{parentName:"li"},"Class"),"."),Object(l.b)("li",{parentName:"ul"},"The query returns all the facts of ",Object(l.b)("inlineCode",{parentName:"li"},"example.Class")," that match the pattern")),Object(l.b)("p",null,"The shell shows results in JSON format. When you\u2019re making Glean\nqueries from code, the results will normally be decoded into native\ndata types that you can manipulate directly in whatever language\nyou\u2019re using; for more details see ",Object(l.b)("a",{parentName:"p",href:"../schema/thrift"},"Thrift and\nJSON"),"."),Object(l.b)("p",null,"Note that each fact has a unique ",Object(l.b)("inlineCode",{parentName:"p"},"id"),". This is how Glean identifies facts in its database. As a user you normally won\u2019t have to worry about fact ",Object(l.b)("inlineCode",{parentName:"p"},"id"),"s; you can think of them like memory addresses."),Object(l.b)("p",null,"The pattern specifies which facts to return. In the example above, our pattern is matching a record type and specifying a subset of the fields: just the ",Object(l.b)("inlineCode",{parentName:"p"},"name")," field. We could match the ",Object(l.b)("inlineCode",{parentName:"p"},"line")," field instead:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=sh"},'facts> example.Class { line = 20 }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n')),Object(l.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(l.b)("div",{parentName:"div",className:"admonition-heading"},Object(l.b)("h5",{parentName:"div"},Object(l.b)("span",{parentName:"h5",className:"admonition-icon"},Object(l.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(l.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(l.b)("div",{parentName:"div",className:"admonition-content"},Object(l.b)("p",{parentName:"div"},"Your patterns should normally match fields at the ",Object(l.b)("em",{parentName:"p"},"beginning")," of the\nrecord, because facts in the database are indexed by a prefix of the\nfields. Matching a field in the middle of the record works by scanning\nall the facts, which could be expensive. We\u2019ll get into this in more\ndetail in ",Object(l.b)("a",{parentName:"p",href:"efficiency"},"Query Efficiency"),"."))),Object(l.b)("p",null,"What other kinds of patterns can we use? Well, the simplest pattern is the wildcard, \u201c_\u201d, which matches anything."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class _\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n{ "id": 1027, "key": { "name": "Goldfish", "line": 40 } }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\n')),Object(l.b)("p",null,"We\u2019ll introduce more kinds of pattern in the following sections. The full list of patterns can be found in ",Object(l.b)("a",{parentName:"p",href:"reference"},"Angle Reference"),"."),Object(l.b)("h2",{id:"matching-nested-facts"},"Matching nested facts"),Object(l.b)("p",null,"The real power of Glean comes from relationships between facts. Facts can refer directly to other facts, and we can write queries that directly match on these connections."),Object(l.b)("p",null,"Our example schema has a predicate that expresses the inheritance relationship between classes:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Parent :\n  {\n     child : Class,\n     parent : Class,\n  }\n")),Object(l.b)("p",null,"Let\u2019s find what ",Object(l.b)("inlineCode",{parentName:"p"},"Fish")," inherits from:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Parent { child = { name = "Fish" }}\n{ "id": 1029, "key": { "child": { "id": 1026 }, "parent": { "id": 1024 } } }\n')),Object(l.b)("p",null,"Let\u2019s break this down."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},'{ child = { name = "Fish" }}')," is a pattern that matches the key type of ",Object(l.b)("inlineCode",{parentName:"li"},"Parent")),Object(l.b)("li",{parentName:"ul"},"So, looking at the schema, ",Object(l.b)("inlineCode",{parentName:"li"},'{ name = "Fish" }')," is a pattern that should match the ",Object(l.b)("inlineCode",{parentName:"li"},"Class")," in the field ",Object(l.b)("inlineCode",{parentName:"li"},"child"),".")),Object(l.b)("p",null,"By default Angle queries are \u201cshallow\u201d, meaning they return just the facts that match and not the nested facts. We can see in the above result that the ",Object(l.b)("inlineCode",{parentName:"p"},"child")," and ",Object(l.b)("inlineCode",{parentName:"p"},"parent")," fields in the result just contain fact references like ",Object(l.b)("inlineCode",{parentName:"p"},'{ "id" : 1026 }'),". If we want to see the content of those references, we can ask Glean to recursively expand facts in the results. In the shell this is done by prefixing the query with ",Object(l.b)("inlineCode",{parentName:"p"},"!"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> ! example.Parent { child = { name = "Fish" }}\n{\n  "id": 1029,\n  "key": {\n    "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n')),Object(l.b)("p",null,"We can of course go the other way and find all the children of a class:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> !example.Parent { parent = { name = "Pet" }}\n{\n  "id": 1028,\n  "key": {\n    "child": { "id": 1025, "key": { "name": "Lizard", "line": 20 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n{\n  "id": 1029,\n  "key": {\n    "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n')),Object(l.b)("p",null,"But as before, note that this would be an inefficient query if we had a lot of data because the pattern is matching on the second field of ",Object(l.b)("inlineCode",{parentName:"p"},"Parent")," (namely ",Object(l.b)("inlineCode",{parentName:"p"},"parent"),"). Later we\u2019ll see how to make these queries more efficient using a derived predicate."),Object(l.b)("h2",{id:"union-types"},"Union types"),Object(l.b)("p",null,"Our examples so far have dealt with record types. Glean also supports ",Object(l.b)("em",{parentName:"p"},"union types"),", also called ",Object(l.b)("em",{parentName:"p"},"sum types"),", which are used to express multiple alternatives. For example, let\u2019s expand our schema to include class members which can be either a method or a variable:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Has :\n  {\n    class_ : Class,\n    has : Member,\n    access : enum { Public | Private },\n  }\n\npredicate Member :\n  {\n    method : { name : string, doc : maybe string } |\n    variable : { name : string }\n  }\n}\n")),Object(l.b)("p",null,"The predicate ",Object(l.b)("inlineCode",{parentName:"p"},"Has")," maps a ",Object(l.b)("inlineCode",{parentName:"p"},"Class")," to a ",Object(l.b)("inlineCode",{parentName:"p"},"Member")," (with a ",Object(l.b)("inlineCode",{parentName:"p"},"Public")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Private")," annotation), and a ",Object(l.b)("inlineCode",{parentName:"p"},"Member")," is either ",Object(l.b)("inlineCode",{parentName:"p"},"method")," or ",Object(l.b)("inlineCode",{parentName:"p"},"variable"),", with some associated data. Note that a ",Object(l.b)("inlineCode",{parentName:"p"},"Class")," might have more than one ",Object(l.b)("inlineCode",{parentName:"p"},"Member"),", which is fine: there can be multiple ",Object(l.b)("inlineCode",{parentName:"p"},"Has")," facts for a given ",Object(l.b)("inlineCode",{parentName:"p"},"Class"),"."),Object(l.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(l.b)("div",{parentName:"div",className:"admonition-heading"},Object(l.b)("h5",{parentName:"div"},Object(l.b)("span",{parentName:"h5",className:"admonition-icon"},Object(l.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(l.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(l.b)("div",{parentName:"div",className:"admonition-content"},Object(l.b)("p",{parentName:"div"},"The schema uses ",Object(l.b)("inlineCode",{parentName:"p"},"class_")," rather than ",Object(l.b)("inlineCode",{parentName:"p"},"class")," as a field name, because ",Object(l.b)("inlineCode",{parentName:"p"},"class")," is a reserved word in Angle. There are many such reserved words, which are reserved not because Angle uses them, but because they cause problems for code that is automatically generated from the schema. To avoid having too many ad-hoc language-specific naming rules, Glean prevents certain problematic names from being used in the schema. The Angle compiler will tell you if you try to use a reserved word."))),Object(l.b)("p",null,"Let\u2019s find classes that have a variable called ",Object(l.b)("inlineCode",{parentName:"p"},"fins"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> !example.Has { has = { variable = { name = "fins" }}}\n{\n  "id": 1036,\n  "key": {\n    "class_": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "has": { "id": 1035, "key": { "variable": { "name": "fins" } } },\n    "access": 1\n  }\n}\n')),Object(l.b)("p",null,"The key thing here is that we matched on ",Object(l.b)("inlineCode",{parentName:"p"},"Member")," which is a union type, using the pattern ",Object(l.b)("inlineCode",{parentName:"p"},'{ variable = { name = "fins" }}'),". A pattern to match a union type looks very much like a record pattern, but it can have only a single field, in this case either ",Object(l.b)("inlineCode",{parentName:"p"},"variable")," or ",Object(l.b)("inlineCode",{parentName:"p"},"method"),"."),Object(l.b)("h2",{id:"maybe"},"Maybe"),Object(l.b)("p",null,"Glean has one built-in union type called ",Object(l.b)("inlineCode",{parentName:"p"},"maybe"),", which is useful when we want to have optional values in the data. It's used in our example schema to attach optional documentation to a class member:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Member :\n  {\n    method : { name : string, doc : maybe string } |\n    variable : { name : string }\n  }\n")),Object(l.b)("p",null,"The type ",Object(l.b)("inlineCode",{parentName:"p"},"maybe string")," behaves exactly as if it were defined as the union type ",Object(l.b)("inlineCode",{parentName:"p"},"{ nothing | just : string }"),".  That means we can write a pattern that matches it, exactly as we would write a pattern for ",Object(l.b)("inlineCode",{parentName:"p"},"{ nothing | just : string }"),":"),Object(l.b)("p",null,"Methods without documentation:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"facts> example.Member { method = { doc = nothing } }\n")),Object(l.b)("p",null,"Methods with documentation:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"facts> example.Member { method = { doc = {  just = _ }}}\n")),Object(l.b)("h2",{id:"or-patterns"},"Or-patterns"),Object(l.b)("p",null,"In a pattern we can express multiple alternatives by separating patterns with a vertical bar ",Object(l.b)("inlineCode",{parentName:"p"},"|"),"."),Object(l.b)("p",null,"For example, we can find classes on lines 20 or 30:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class { line = 20 | 30 }\n{ "id": 1025, "key": { "name": "Lizard", "line": 20 } }\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n')),Object(l.b)("p",null,"Or we can find all the classes that have either a ",Object(l.b)("inlineCode",{parentName:"p"},"method")," called ",Object(l.b)("inlineCode",{parentName:"p"},"feed")," or a ",Object(l.b)("inlineCode",{parentName:"p"},"variable")," with any name:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { has = { method = { name = "feed" }} | { variable = _ }}\n\n(results omitted)\n')),Object(l.b)("h2",{id:"more-complex-queries"},"More complex queries"),Object(l.b)("p",null,"So far we\u2019ve seen how to query for facts by matching patterns, including matching nested facts.  In this section we\u2019ll see how to construct more complex queries that combine matching facts from multiple predicates."),Object(l.b)("p",null,"Suppose we want to find all the parents of classes that have a variable called ",Object(l.b)("inlineCode",{parentName:"p"},"fins"),". We need to build a query that will"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"find the classes with a variable called ",Object(l.b)("inlineCode",{parentName:"li"},"fins")," using ",Object(l.b)("inlineCode",{parentName:"li"},"example.Has")," as we did above"),Object(l.b)("li",{parentName:"ul"},"find their parents using ",Object(l.b)("inlineCode",{parentName:"li"},"example.Parent"))),Object(l.b)("p",null,"We can combine these two as follows:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'example.Has\n  {\n    class_ = C,\n    has = { variable = { name = "fins" }}\n  };\nexample.Parent { child = C }\n')),Object(l.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(l.b)("div",{parentName:"div",className:"admonition-heading"},Object(l.b)("h5",{parentName:"div"},Object(l.b)("span",{parentName:"h5",className:"admonition-icon"},Object(l.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(l.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(l.b)("div",{parentName:"div",className:"admonition-content"},Object(l.b)("p",{parentName:"div"},"I\u2019ve written this on several lines with indentation to illustrate it\nbetter, to do this in the shell you will need to use the ",Object(l.b)("inlineCode",{parentName:"p"},":edit"),"\ncommand to put the query in a temporary file."))),Object(l.b)("p",null,"The key thing here is that we used a ",Object(l.b)("em",{parentName:"p"},"variable")," ",Object(l.b)("inlineCode",{parentName:"p"},"C")," to stand for the ",Object(l.b)("inlineCode",{parentName:"p"},"class_")," field when matching facts of ",Object(l.b)("inlineCode",{parentName:"p"},"example.Has"),", and then we searched for ",Object(l.b)("inlineCode",{parentName:"p"},"example.Parent")," facts with the same value of ",Object(l.b)("inlineCode",{parentName:"p"},"C")," for the ",Object(l.b)("inlineCode",{parentName:"p"},"child")," field."),Object(l.b)("p",null,"Note that variables must ",Object(l.b)("em",{parentName:"p"},"always")," begin with an upper-case letter, while schema names (",Object(l.b)("inlineCode",{parentName:"p"},"example)")," and field names (",Object(l.b)("inlineCode",{parentName:"p"},"child"),") begin with a lower-case letter."),Object(l.b)("p",null,"The semicolon separates multiple ",Object(l.b)("em",{parentName:"p"},"statements")," in a query. When there are multiple statements the results of the query are the facts that match the last statement, in this case the ",Object(l.b)("inlineCode",{parentName:"p"},"example.Parent"),".  Let\u2019s try it:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> ! example.Has { class_ = C, has = { variable = { name = "fins" }}}; example.Parent { child = C }\n{\n  "id": 1029,\n  "key": {\n    "child": { "id": 1026, "key": { "name": "Fish", "line": 30 } },\n    "parent": { "id": 1024, "key": { "name": "Pet", "line": 10 } }\n  }\n}\n')),Object(l.b)("p",null," Suppose we don\u2019t care too much about the child here, we only care about getting a list of the parents. We can avoid returning the redundant information by specifying explicitly what it is we want to return from the query:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'P where\n    example.Has\n      {\n        class_ = C,\n        has = { variable = { name = "fins" }}\n      };\n    example.Parent { child = C, parent = P }\n')),Object(l.b)("p",null,"The general form of the query is ",Object(l.b)("em",{parentName:"p"},Object(l.b)("inlineCode",{parentName:"em"},"expression"))," ",Object(l.b)("inlineCode",{parentName:"p"},"where")," ",Object(l.b)("em",{parentName:"p"},Object(l.b)("inlineCode",{parentName:"em"},"statements")),", where ",Object(l.b)("em",{parentName:"p"},Object(l.b)("inlineCode",{parentName:"em"},"expression"))," is an arbitrary expression and each statement is a pattern that matches some facts. The results of the query are the distinct values of ",Object(l.b)("em",{parentName:"p"},Object(l.b)("inlineCode",{parentName:"em"},"expression"))," for which all the statements match facts in the database."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> ! P where example.Has { class_ = C, has = { variable = { name = "fins" }}}; example.Parent { child = C, parent = P }\n{ "id": 1024, "key": { "name": "Pet", "line": 10 } }\n')),Object(l.b)("h2",{id:"statements"},"Statements"),Object(l.b)("p",null,"In general, a statement can be of the form ",Object(l.b)("em",{parentName:"p"},"A = B.")," For example, if we write"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'C = example.Class { name = "Fish" };\nexample.Parent { child = C }\n')),Object(l.b)("p",null,"that\u2019s the same as"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'example.Parent { child = { name = "Fish" }}\n')),Object(l.b)("p",null,"A statement can have a pattern on either side, for example"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'C where\n  C = example.Class { name = N };\n  N = "Fish" | "Goldfish"\n')),Object(l.b)("p",null,"A statement can itself be a set of alternatives separated by a vertical bar ",Object(l.b)("inlineCode",{parentName:"p"},"|"),". For example, we can find classes that are either a parent of the ",Object(l.b)("inlineCode",{parentName:"p"},"Goldfish")," or have a ",Object(l.b)("inlineCode",{parentName:"p"},"feed")," method:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'C where\n  example.Parent { child = { name = "Goldfish" }, parent = C } |\n  example.Has { class_ = C, has = { method = { name = "feed" }}}\n')),Object(l.b)("h2",{id:"arrays"},"Arrays"),Object(l.b)("p",null,"When the schema uses an array, we need to be able to write queries that traverse the elements of the array. For example, a common use of an array is to represent the list of declarations in a source file. Our example schema defines the ",Object(l.b)("inlineCode",{parentName:"p"},"FileClasses")," predicate:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate FileClasses :\n  {\n    file : string,\n    classes : [Class]\n  }\n")),Object(l.b)("p",null,"The goal here is to map efficiently from a filename to the list of classes defined in that file. Suppose we want to write a query that finds all the classes called ",Object(l.b)("inlineCode",{parentName:"p"},"Goldfish")," in the file ",Object(l.b)("inlineCode",{parentName:"p"},"petshop.example"),", we could do it like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'example.FileClasses { file = "petshop.example", classes = Cs };\n{ name = "Goldfish" } = Cs[..]\n')),Object(l.b)("p",null,"The second line is the interesting one: ",Object(l.b)("inlineCode",{parentName:"p"},'{ name = "Goldfish" } = Cs[..]')," means"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"on the right-hand side, ",Object(l.b)("inlineCode",{parentName:"li"},"Cs[..]")," means \u201ceach element of the array ",Object(l.b)("inlineCode",{parentName:"li"},"Cs"),"\u201d"),Object(l.b)("li",{parentName:"ul"},"the left-hand side is a pattern, filtering only those ",Object(l.b)("inlineCode",{parentName:"li"},"Class")," facts that match ",Object(l.b)("inlineCode",{parentName:"li"},'{ name = "Goldfish" }'))),Object(l.b)("p",null,"We can also match the whole array with a pattern of the form ",Object(l.b)("inlineCode",{parentName:"p"},"[ p1, p2, ... ]")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> X where [_,X,_] = [1,2,3]\n{ "id": 1040, "key": 2 }\n')),Object(l.b)("h2",{id:"string-prefix"},"String prefix"),Object(l.b)("p",null,"We\u2019ve seen many examples of patterns that match strings. Glean also supports matching strings by ",Object(l.b)("em",{parentName:"p"},"prefix"),"; for example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Class { name = "F".. }\n{ "id": 1026, "key": { "name": "Fish", "line": 30 } }\n')),Object(l.b)("p",null,"The syntax ",Object(l.b)("inlineCode",{parentName:"p"},'"F"..')," means ",Object(l.b)("em",{parentName:"p"},"strings beginning with the prefix")," ",Object(l.b)("inlineCode",{parentName:"p"},'\u201dF"'),"."),Object(l.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(l.b)("div",{parentName:"div",className:"admonition-heading"},Object(l.b)("h5",{parentName:"div"},Object(l.b)("span",{parentName:"h5",className:"admonition-icon"},Object(l.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(l.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(l.b)("div",{parentName:"div",className:"admonition-content"},Object(l.b)("p",{parentName:"div"},"Why only prefix and not substring matching in general? Prefix matching can be supported efficiently by Glean\u2019s prefix-tree representation of the fact database. Other kinds of string matching could be supported, but they wouldn\u2019t be able to exploit the database representation so there\u2019s little advantage to implementing them in Angle compared with filtering on the client-side."))),Object(l.b)("h2",{id:"tuples"},"Tuples"),Object(l.b)("p",null,"A ",Object(l.b)("em",{parentName:"p"},"tuple")," is just a a way of writing a record without the field names.  So for example, instead of"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"example.Parent { child = C }\n")),Object(l.b)("p",null,"we could write"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"example.Parent { C, _ }\n")),Object(l.b)("p",null,"When using a tuple you have to list ",Object(l.b)("em",{parentName:"p"},"all")," the fields, in the same order as they are declared in the schema.  That's why ",Object(l.b)("inlineCode",{parentName:"p"},"{ child = C }")," becomes ",Object(l.b)("inlineCode",{parentName:"p"},"{ C, _ }")," when written as a tuple."),Object(l.b)("p",null,"There are upsides and downsides to using the tuple notation:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Pro: more concise"),Object(l.b)("li",{parentName:"ul"},"Con: brittle and sensitive to changes in the schema. If we add a field, then tuple patterns will break whereas record patterns won't.")),Object(l.b)("p",null,'As a rule of thumb we tend to use tuple syntax in cases where the predicate is "obviously" a relation, such as ',Object(l.b)("inlineCode",{parentName:"p"},"example.Parent"),", but we wouldn't use tuple syntax for more complex records."),Object(l.b)("h2",{id:"enums-and-bool"},"Enums and bool"),Object(l.b)("p",null,"An ",Object(l.b)("inlineCode",{parentName:"p"},"enum")," type is a set of named constants. In the ",Object(l.b)("inlineCode",{parentName:"p"},"Has")," predicate we used an ",Object(l.b)("inlineCode",{parentName:"p"},"enum")," type to indicate whether a class member is ",Object(l.b)("inlineCode",{parentName:"p"},"Public")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Private"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"predicate Has :\n  {\n    class_ : Class,\n    has : Member,\n    access : enum { Public | Private },\n  }\n")),Object(l.b)("p",null,"To match an ",Object(l.b)("inlineCode",{parentName:"p"},"enum")," we just use the appropriate identifier, in this case ",Object(l.b)("inlineCode",{parentName:"p"},"Public")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Private"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},'facts> example.Has { access = Private }\n{ "id": 1036, "key": { "class_": { "id": 1026 }, "has": { "id": 1035 }, "access": 1 } }\n')),Object(l.b)("p",null,"Note that in the JSON format results, an ",Object(l.b)("inlineCode",{parentName:"p"},"enum")," is represented by an integer. When you make queries in code, the ",Object(l.b)("inlineCode",{parentName:"p"},"enum")," will be represented by an appropriate type, such as a ",Object(l.b)("inlineCode",{parentName:"p"},"data")," type in Haskell."),Object(l.b)("p",null,"The boolean type ",Object(l.b)("inlineCode",{parentName:"p"},"bool")," is a special case of an ",Object(l.b)("inlineCode",{parentName:"p"},"enum"),", defined like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-lang=angle"},"type bool = enum { false | true }\n")))}m.isMDXComponent=!0}}]);